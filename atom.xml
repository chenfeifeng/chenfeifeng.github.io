<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>九客</title>
  <subtitle>一天进步一点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/chenfeifeng/chenfeifeng.github.io.git/"/>
  <updated>2017-06-11T16:05:53.000Z</updated>
  <id>https://github.com/chenfeifeng/chenfeifeng.github.io.git/</id>
  
  <author>
    <name>Joker_Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>shiro</title>
    <link href="https://github.com/chenfeifeng/chenfeifeng.github.io.git/2016/09/06/shiro%E7%94%A8%E6%88%B7%E5%A4%B1%E6%95%88,%E7%AE%80%E5%8D%95%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95/"/>
    <id>https://github.com/chenfeifeng/chenfeifeng.github.io.git/2016/09/06/shiro用户失效,简单控制方法/</id>
    <published>2016-09-06T14:47:18.000Z</published>
    <updated>2017-06-11T16:05:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shiro用户失效"><a href="#shiro用户失效" class="headerlink" title="shiro用户失效,"></a>shiro用户失效,</h1><h2 id="现象"><a href="#现象" class="headerlink" title="现象:"></a>现象:</h2><ol>
<li>在使用shiro控制权限,当用户登录之后,比如设置了30分钟的失效时间,然后30分钟过去之后,用户实现</li>
<li>此时shiro会过滤每一次接口,判断是否是有效用户(即是否能够调用接口),因为此时用户已经失效,那么shiro直接会将接口重定向到loginUrl中去,但是这个是后端的重定向,前端无法跳转到登录页面,只能再次刷新.</li>
</ol>
<a id="more"></a>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案:"></a>方案:</h2><ol>
<li>思路:debug,查看源码,发现是在一个AccessControlFilter中的onAccessDenied方法中去做重定向跳转,那么需要在shiro执行302重定向之前,将这种情况处理掉(返回特定的status,让前端去跳转到登录页面)</li>
<li>可以重写shiro的过滤器,但是暂时无法确认其他地方调用到AccessControlFilter改过滤器的情况,所以选择了相对比较简单的方法</li>
<li>就是直接修改loginUrl,将loginUrl定为一个特定的接口(会返回给前端特定的status,直接跳转到登录页面)</li>
</ol>
<h2 id="实现1"><a href="#实现1" class="headerlink" title="实现1:"></a>实现1:</h2><p>1.修改下面代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"shiroFilter"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;</div><div class="line">        <span class="xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loginUrl"</span> <span class="attr">value</span>=<span class="string">"/opercentre/access/denied"</span>/&gt;</span></span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>2.实现该接口<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/opercentre/access"</span>)</div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RequestAccessAction</span> <span class="keyword">extends</span> <span class="title">BaseAction</span> </span>&#123;</div><div class="line">	<span class="type">Logger</span> logger = <span class="type">LoggerFactory</span>.getLogger(<span class="type">RequestAccessAction</span>.<span class="keyword">class</span>);</div><div class="line"></div><div class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"/denied"</span>)</div><div class="line">	<span class="meta">@ResponseBody</span></div><div class="line">	public <span class="type">RespContent</span> getDepatUser() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="type">RespContent</span>(<span class="type">Status</span>.<span class="type">UNAUTHORIZED</span>.getStatusCode(), <span class="string">"请重新登录"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.这样当用户失效的时候,会302重定向到改接口,然后返回UNAUTHORIZED的code给前端,让前端实现跳转</p>
<p><strong>改方法有点,改变了shiro中loginUrl地址的含义,不过是最简单的处理shiro用户失效问题方法</strong></p>
<h2 id="实现2"><a href="#实现2" class="headerlink" title="实现2:"></a>实现2:</h2><ol>
<li>重写FormAuthenticationFilter方法</li>
<li><p>创建一个filter继承FormAuthenticationFilter类,除了重定向代码,重写onAccessDenied,其他代码不变:</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="built_in">boolean</span> onAccessDenied(ServletRequest request, ServletResponse response) <span class="keyword">throws</span> Exception &#123;</div><div class="line">        <span class="keyword">if</span> (isLoginRequest(request, response)) &#123;</div><div class="line">            <span class="keyword">if</span> (isLoginSubmission(request, response)) &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="built_in">log</span>.isTraceEnabled()) &#123;</div><div class="line">                    <span class="built_in">log</span>.trace(<span class="string">"Login submission detected.  Attempting to execute login."</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> executeLogin(request, response);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="built_in">log</span>.isTraceEnabled()) &#123;</div><div class="line">                    <span class="built_in">log</span>.trace(<span class="string">"Login page view."</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//allow them to see the login page ;)</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">log</span>.isTraceEnabled()) &#123;</div><div class="line">                <span class="built_in">log</span>.trace(<span class="string">"Attempting to access a path which requires authentication.  Forwarding to the "</span> +</div><div class="line">                        <span class="string">"Authentication url ["</span> + getLoginUrl() + <span class="string">"]"</span>);</div><div class="line">            &#125;</div><div class="line"><span class="comment">//            saveRequestAndRedirectToLogin(request, response);</span></div><div class="line">            HttpServletResponse res= (HttpServletResponse) response;</div><div class="line">            res.sendRedirect(res.encodeRedirectURL(<span class="string">"/boss/opercentre/access/denied"</span>));</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>修改shiro配置:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"shiroFilter"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filters"</span>&gt;</span></span></div><div class="line">            <span class="tag">&lt;<span class="name">util:map</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"timeout"</span> <span class="attr">value-ref</span>=<span class="string">"TimeoutFilter"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">util:map</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filterChainDefinitions"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span></div><div class="line">            	/opercentre/**=timeout</div><div class="line">            <span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>这样是重写filter方法,扩展性相对比较高</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;shiro用户失效&quot;&gt;&lt;a href=&quot;#shiro用户失效&quot; class=&quot;headerlink&quot; title=&quot;shiro用户失效,&quot;&gt;&lt;/a&gt;shiro用户失效,&lt;/h1&gt;&lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象:&quot;&gt;&lt;/a&gt;现象:&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在使用shiro控制权限,当用户登录之后,比如设置了30分钟的失效时间,然后30分钟过去之后,用户实现&lt;/li&gt;
&lt;li&gt;此时shiro会过滤每一次接口,判断是否是有效用户(即是否能够调用接口),因为此时用户已经失效,那么shiro直接会将接口重定向到loginUrl中去,但是这个是后端的重定向,前端无法跳转到登录页面,只能再次刷新.&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="java" scheme="https://github.com/chenfeifeng/chenfeifeng.github.io.git/categories/java/"/>
    
    
      <category term="shiro" scheme="https://github.com/chenfeifeng/chenfeifeng.github.io.git/tags/shiro/"/>
    
  </entry>
  
  <entry>
    <title>shiro</title>
    <link href="https://github.com/chenfeifeng/chenfeifeng.github.io.git/2016/09/04/shiro2/"/>
    <id>https://github.com/chenfeifeng/chenfeifeng.github.io.git/2016/09/04/shiro2/</id>
    <published>2016-09-04T08:06:45.000Z</published>
    <updated>2016-09-06T14:47:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shiro认识"><a href="#shiro认识" class="headerlink" title="shiro认识"></a>shiro认识</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>shiro是Apache出的一个Java安全框架,提供了认证,授权,加密,会话管理,web集成和缓存等功能.</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0093/9788/d59f6d02-1f45-3285-8983-4ea5f18111d5.png" alt=""></p>
<a id="more"></a>
<p>Authentication：身份认证/登录，验证用户是不是拥有相应的身份；</p>
<p>Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</p>
<p>Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的；</p>
<p>Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</p>
<p>Web Support：Web支持，可以非常容易的集成到Web环境；</p>
<p>Caching：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；</p>
<p>Concurrency：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</p>
<p>Testing：提供测试支持；</p>
<p>Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</p>
<p>Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</p>
<h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p>Shiro的三个核心组件：Subject, SecurityManager 和 Realms. 如下图：<br><img src="http://fh-1.qiniudn.com/shiro/shiro-core.png" alt=""></p>
<h3 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h3><p>即“当前操作用户”。但是，在Shiro中，Subject这一概念并不仅仅指人，也可以是第三方进程、后台帐户（Daemon Account）或其他类似事物。它仅仅意味着“当前跟软件交互的东西”。但考虑到大多数目的和用途，你可以把它认为是Shiro的“用户”概念。Subject代表了当前用户的安全操作，SecurityManager则管理所有用户的安全操作。与Subject的所有交互都会委托给SecurityManager。</p>
<h3 id="SecurityManager"><a href="#SecurityManager" class="headerlink" title="SecurityManager"></a>SecurityManager</h3><p>安全管理器；即所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject；可以看出它是Shiro的核心，它负责与后边介绍的其他组件进行交互，如果学习过SpringMVC，你可以把它看成DispatcherServlet前端控制器；</p>
<h3 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h3><p>Realm充当了Shiro与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。从这个意义上讲，Realm实质上是一个安全相关的DAO：它封装了数据源的连接细节，并在需要时将相关数据提供给Shiro。当配置Shiro时，你必须至少指定一个Realm，用于认证和（或）授权。配置多个Realm是可以的，但是至少需要一个。Shiro内置了可以连接大量安全数据源（又名目录）的Realm，如LDAP、关系数据库（JDBC）、类似INI的文本配置资源以及属性文件等。如果缺省的Realm不能满足需求，你还可以插入代表自定义数据源的自己的Realm实现。</p>
<p>也就是说对于我们而言，最简单的一个Shiro应用：</p>
<p>1、应用代码通过Subject来进行认证和授权，而Subject又委托给SecurityManager；</p>
<p>2、我们需要给Shiro的SecurityManager注入Realm，从而让SecurityManager能得到合法的用户及其权限进行判断。</p>
<p>从以上也可以看出，Shiro不提供维护用户/权限，而是通过Realm让开发人员自己注入(即需要我们自己管理Realm)。</p>
<h2 id="shiro的使用"><a href="#shiro的使用" class="headerlink" title="shiro的使用"></a>shiro的使用</h2><h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><p>认证就是验证用户身份的过程。在认证过程中，用户需要提交实体信息(Principals)和凭据信息(Credentials)以检验用户是否合法。最常见的“实体/凭证”组合便是“用户名/密码”组合。</p>
<pre><code>AuthenticationToken token = new UsernamePasswordToken(
  operUser.getOperUserName(), operUser.getPassWord());
Subject subject = SecurityUtils.getSubject();
try {
    subject.login(token);
    if (!subject.isAuthenticated()) {
        return new RespContent(&quot;400&quot;, &quot;用户认证失败！&quot;);
    }
} catch (UnknownAccountException uae) {
      log.info(&quot;There is no user with username of &quot; + token.getPrincipal());
} catch (IncorrectCredentialsException ice) {
      log.info(&quot;Password for account &quot; + token.getPrincipal() + &quot; was incorrect!&quot;);
} catch (LockedAccountException lae) {
      log.info(&quot;The account for username &quot; + token.getPrincipal() + &quot; is locked. &quot; +
       &quot;Please contact your administrator to unlock it.&quot;);
}
// ... 捕获更多异常
catch (AuthenticationException ae) {
      // 无定义错误?
}
//完成 - 退出t!
subject.logout();
</code></pre><p>身份验证的主要流程就是：</p>
<ul>
<li>收集用户身份/凭证，即如用户名/密码；</li>
<li>调用 Subject.login 进行登录，如果失败将得到相应的 AuthenticationException 异常，根<br>据异常提示用户错误信息；否则登录成功；</li>
<li>最后调用 Subject.logout 进行退出操作。</li>
</ul>
<h4 id="—收集信息"><a href="#—收集信息" class="headerlink" title="—收集信息"></a>—收集信息</h4><p>UsernamePasswordToken支持最常见的用户名/密码的认证机制。同时，由于它实现了RememberMeAuthenticationToken接口，我们可以通过令牌设置“记住我”的功能。但是，“已记住”和“已认证”是有区别的：已记住的用户仅仅是非匿名用户，你可以通过subject.getPrincipals()获取用户信息。但是它并非是完全认证通过的用户，当你访问需要认证用户的功能时，你仍然需要重新提交认证信息。这一区别可以参考亚马逊网站，网站会默认记住登录的用户，再次访问网站时，对于非敏感的页面功能，页面上会显示记住的用户信息，但是当你访问网站账户信息时仍然需要再次进行登录认证。 subject.isAuthenticated()和subject.isRemembered()的值总是相反的。</p>
<h4 id="—认证处理"><a href="#—认证处理" class="headerlink" title="—认证处理"></a>—认证处理</h4><p>如果login方法执行完毕且没有抛出任何异常信息，那么便认为用户认证通过。之后在应用程序任意地方调用SecurityUtils.getSubject() 都可以获取到当前认证通过的用户实例，使用subject.isAuthenticated()判断用户是否已验证都将返回true. 相反，如果login方法执行过程中抛出异常，那么将认为认证失败。Shiro有着丰富的层次鲜明的异常类来描述认证失败的原因，如代码示例。</p>
<h4 id="—登出操作"><a href="#—登出操作" class="headerlink" title="—登出操作"></a>—登出操作</h4><pre><code>Subject subject = SecurityUtils.getSubject();
subject.logout();
</code></pre><p>源码如下:</p>
<pre><code>//清空了session中的登录信息,subject将被视作为匿名用户
public void logout() {
    try {
      clearRunAsIdentitiesInternal();//清楚内部身份信息清楚session
      this.securityManager.logout(this);//删除当前subject信息
      this.session = null;
      this.principals = null;
      this.authenticated = false;
    } finally {
      this.session = null;
      this.principals = null;
      this.authenticated = false;
    }
}
</code></pre><h3 id="Realm的实现"><a href="#Realm的实现" class="headerlink" title="Realm的实现"></a>Realm的实现</h3><pre><code>public class MyAuthorizingRealm extends AuthorizingRealm {
    //在有权限验证的时候进入,进行权限获取
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
        if (principals == null) {
            throw new AuthorizationException(&quot;PrincipalCollection method
            argument cannot be null.&quot;);
        }
        String username = (String) getAvailablePrincipal(principals);
        Set&lt;String&gt; roleNames = new HashSet&lt;&gt;();
        Set&lt;String&gt; permissions = new HashSet&lt;&gt;();
        // 获取权限和角色存入SimpleAuthorizationInfo中
        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(roleNames);
        info.setStringPermissions(permissions);
        return info;
    }

    //首次登录时进行subject的信息存储
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token)
    throws AuthenticationException {
        UsernamePasswordToken upToken = (UsernamePasswordToken) token;
        String username = upToken.getUsername();
        if (username == null) {
            throw new AccountException(&quot;Null usernames are not allowed by this realm.&quot;);
        }

        OpercentreUser user = opercentreUserService.getLoginOperUser(username);
        if (user == null) {
          throw new UnknownAccountException(&quot;No account found for user [&quot; + username + &quot;]&quot;);
        }

        String password = user.getPassWord();

        if (password == null) {
            throw new UnknownAccountException(&quot;No account found for user [&quot; + username + &quot;]&quot;);
        }

        SimpleAuthenticationInfo saInfo = new SimpleAuthenticationInfo(username,
          password, getName());
        saInfo.setCredentialsSalt(ByteSource.Util.bytes(user.getSalt()));
        return saInfo;
    }
}
</code></pre><p>一般继承AuthorizingRealm即可，需要实现getAuthenticationInfo(AuthenticationToken token)和doGetAuthenticationInfo(PrincipalCollection principals)两个方法</p>
<h3 id="多个Realm认证"><a href="#多个Realm认证" class="headerlink" title="多个Realm认证"></a>多个Realm认证</h3><p>shiro也可以有多个Realm的认证:</p>
<pre><code>&lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;  
    &lt;!-- 其他配置 --&gt;  
    &lt;property name=&quot;authenticator&quot; ref=&quot;authenticator&quot; /&gt;  
    &lt;property name=&quot;realms&quot;&gt;  
        &lt;list&gt;  
            &lt;ref bean=&quot;defaultJdbcRealm&quot; /&gt;  
            &lt;ref bean=&quot;backDoorJdbcRealm&quot; /&gt;  
        &lt;/list&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;
&lt;bean id=&quot;defaultJdbcRealm&quot; class=&quot;...&quot; /&gt;  
&lt;bean id=&quot;backDoorJdbcRealm&quot; class=&quot;...&quot; /&gt;
&lt;bean id=&quot;authenticator&quot; class=&quot;xxx.yyy.security.ModularRealmAuthenticator&quot;&gt;  
    &lt;property name=&quot;authenticationStrategy&quot;&gt;  
        &lt;bean class=&quot;org.apache.shiro.authc.pam.FirstSuccessfulStrategy&quot; /&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;  
</code></pre><p>多个Realm的时候可以定义认证策略authenticationStrategy:</p>
<ul>
<li>AtLeastOneSuccessfulStrategy 只要有一个（或更多）的Realm验证成功，那么认证将被视为成功</li>
<li>FirstSuccessfulStrategy 第一个Realm验证成功，整体认证将被视为成功，且后续Realm将被忽略</li>
<li>AllSuccessfulStrategy 所有Realm成功，认证才视为成功</li>
</ul>
<p>ModularRealmAuthenticator 内置的认证策略默认实现是AtLeastOneSuccessfulStrategy 方式，因为这种方式也是被广泛使用的一种认证策略</p>
<h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>授权有着三个核心元素：权限(permissions)、角色(roles)和用户(users)。</p>
<p>Shiro支持三种方式实现授权过程：</p>
<ul>
<li>编码实现：if(subject.hasRole(“admin”)){//有权限}</li>
<li>注解实现：@RequiresRoles(“admin”)public void hello() {//有权限}</li>
<li>JSP Taglig实现：<shiro:hasrole name="admin">&lt;!— 有权限 —&gt;</shiro:hasrole></li>
</ul>
<p>使用注解进行权限控制:(开启注解和spring的类似)</p>
<pre><code>&lt;bean class=&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt;
</code></pre><p>   <property name="securityManager" ref="securityManager"><br>    </property></p>
<p>注解类型:</p>
<p>@RequiresAuthentication:要求当前Subject 已经在当前的session 中被验证通过才能被访问或调用.</p>
<p>@RequiresGuest:要求当前的Subject 是一个”guest”，也就是说，他们必须是在之前的session 中没有被验证或被记住才能被访问或调用.</p>
<p>@RequiresPermissions(“权限”):要求当前的Subject 被允许一个或多个权限，以便执行注解的方法.</p>
<pre><code>subject.isPermitted(&quot;权限&quot;)
</code></pre><p>@RequiresRoles(“角色”):要求当前的Subject 拥有所有指定的角色。如果他们没有，则该方法将不会被执行，而且AuthorizationException 异常将会被抛出.</p>
<pre><code>subject.hasRole(&quot;角色&quot;)
</code></pre><p>以上权限配置如果未通过会直接抛异常,AuthorizationException(授权异常)和UnauthenticatedException(验证异常)最为多见,可以自己spring全局异常捕捉控制.</p>
<p>Shiro还支持以断言的方式进行授权验证。断言成功，不返回任何值，程序继续执行；断言失败时，将抛出异常信息。<br>比如subject.checkRole(String roleName)和subject.checkPermission(String permission)授权处理过程中：</p>
<ol>
<li>当调用Realm出现异常时，将立即抛出异常，结束授权验证。</li>
<li>只要有一个Realm验证成功，那么将认为授权成功，立即返回，结束认证。</li>
</ol>
<h3 id="基于JSP-TAG的授权实现"><a href="#基于JSP-TAG的授权实现" class="headerlink" title="基于JSP TAG的授权实现"></a>基于JSP TAG的授权实现</h3><p>Shiro提供了一套JSP标签库来实现页面级的授权控制。标签库描述文件 (TLD)被打包在 META-INF/shiro.tld 文件中的 shiro-web.jar 文件中。</p>
<p>在使用Shiro标签库前，首先需要在JSP引入shiro标签：</p>
<pre><code>&lt;%@ taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;
</code></pre><p>下面一一介绍Shiro的标签：</p>
<p>guest标签:验证当前用户是否为“访客”，即未认证（包含未记住）的用户</p>
<pre><code>&lt;shiro:guest&gt;
    Hi there!  Please &lt;a href=&quot;login.jsp&quot;&gt;Login&lt;/a&gt; or &lt;a href=&quot;signup.jsp&quot;&gt;Signup&lt;/a&gt; today!
&lt;/shiro:guest&gt;
</code></pre><p>user标签:认证通过或已记住的用户</p>
<pre><code>&lt;shiro:user&gt;  
    Welcome back John!  Not John? Click &lt;a href=&quot;login.jsp&quot;&gt;here&lt;a&gt; to login.  
&lt;/shiro:user&gt;
</code></pre><p>authenticated标签:已认证通过的用户。不包含已记住的用户，这是与user标签的区别所在。</p>
<pre><code>&lt;shiro:authenticated&gt;  
    &lt;a href=&quot;updateAccount.jsp&quot;&gt;Update your contact information&lt;/a&gt;.  
&lt;/shiro:authenticated&gt;
</code></pre><p>notAuthenticated标签:未认证通过用户，与authenticated标签相对应。与guest标签的区别是，该标签包含已记住用户。</p>
<pre><code>&lt;shiro:notAuthenticated&gt;  
    Please &lt;a href=&quot;login.jsp&quot;&gt;login&lt;/a&gt; in order to update
    your credit card information.  
&lt;/shiro:notAuthenticated&gt;
</code></pre><p>hasRole标签:验证当前用户是否属于该角色</p>
<pre><code>&lt;shiro:hasRole name=&quot;administrator&quot;&gt;  
    &lt;a href=&quot;admin.jsp&quot;&gt;Administer the system&lt;/a&gt;  
&lt;/shiro:hasRole&gt;
</code></pre><p>lacksRole标签:与hasRole标签逻辑相反，当用户不属于该角色时验证通过</p>
<pre><code>&lt;shiro:lacksRole name=&quot;administrator&quot;&gt;  
    Sorry, you are not allowed to administer the system.  
&lt;/shiro:lacksRole&gt;
</code></pre><p>hasAnyRole标签:验证当前用户是否属于以下任意一个角色。</p>
<pre><code>&lt;shiro:hasAnyRoles name=&quot;developer, project manager, administrator&quot;&gt;  
    You are either a developer, project manager, or administrator.  
&lt;/shiro:lacksRole&gt;
</code></pre><p>hasPermission标签:验证当前用户是否拥有制定权限</p>
<pre><code>&lt;shiro:hasPermission name=&quot;user:create&quot;&gt;  
    &lt;a href=&quot;createUser.jsp&quot;&gt;Create a new User&lt;/a&gt;  
&lt;/shiro:hasPermission&gt;
</code></pre><p>lacksPermission标签:与hasPermission标签逻辑相反，当前用户没有制定权限时，验证通过</p>
<pre><code>&lt;shiro:hasPermission name=&quot;user:create&quot;&gt;  
    &lt;a href=&quot;createUser.jsp&quot;&gt;Create a new User&lt;/a&gt;  
&lt;/shiro:hasPermission&gt;
</code></pre><h3 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h3><p><img src="http://fh-1.qiniudn.com/shiro/Shiro-AuthorizationSequence.png" alt=""></p>
<ol>
<li>程序或框架代码调用一个 Subject 的hasRole<em>、checkRole</em>、isPermitted<em>或者checkPermission</em>方法，传递所需的权限或角色。</li>
<li>Subject实例，通常是一个 DelegatingSubject（或子类），通过调用securityManager 与各 hasRole<em>、checkRole</em>、isPermitted<em>或checkPermission</em> 基本一致的方法将权限或角色传递给程序的 SecurityManager(实现了 org.apache.shiro.authz.Authorizer 接口)。</li>
<li>接下来SecurityManager会委托内置的Authorizer的实例（默认是ModularRealmAuthorizer 类的实例，类似认证实例，它同样支持一个或多个Realm实例认证）调用相应的授权方法。</li>
<li>每一个Realm将检查是否实现了相同的 Authorizer 接口。然后，将调用Reaml自己的相应的授权验证方法。</li>
</ol>
<p>在认证、授权内部实现机制中都有提到，最终处理都将交给Realm进行处理。因为在Shiro中，最终是通过Realm来获取应用程序中的用户、角色及权限信息的。通常情况下，在Realm中会直接从我们的数据源中获取Shiro需要的验证信息。可以说，Realm是专用于安全框架的DAO.</p>
<h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><p>Shiro 提供了完整的企业级会话管理功能，不依赖于底层容器（如 web 容器 tomcat），不管JavaSE 还是 JavaEE 环境都可以使用，提供了会话管理、会话事件监听、会话存储/持久化、容器无关的集群、失效/过期支持、对 Web 的透明支持、SSO 单点登录的支持等特性。</p>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>登录成功后使用 Subject.getSession()即可获取会话；其等价于 Subject.getSession(true)，即如果当前没有创建 Session 对象会创建一个；另外 Subject.getSession(false)，如果当前没有创建 Session 则返回 null</p>
<ul>
<li>session.getId(); //获取会话唯一标识</li>
<li>session.getHost(); //获取 Subject的主机地址,该地址是通过 HostAuthenticationToken.getHost()提供的</li>
<li>session.getTimeout(); //获取过期时间</li>
<li>session.setTimeout(毫秒); //设置会话过期时间</li>
<li>session.getStartTimestamp(); //获取会话启动时间</li>
<li>session.getLastAccessTime(); //获取最后访问时间</li>
<li>session.touch(); //更新最后访问时间</li>
<li>session.stop(); //销毁会话。</li>
<li>session.setAttribute(“key”, “123”); //设置session属性</li>
<li>ession.getAttribute(“key”)); //获取session属性</li>
<li>session.removeAttribute(“key”); //删除会话属性</li>
</ul>
<h3 id="会话管理器"><a href="#会话管理器" class="headerlink" title="会话管理器"></a>会话管理器</h3><p>SessionManager，名如其意，在应用程序中为所有的 subject 管理Session —— 创建，删除，失效及验证，等等。如同其他在Shiro 中的核心结构组件一样，SessionManager 也是一个由 SecurityManager 维护的顶级组件。</p>
<ul>
<li>Session start(SessionContext context); //启动会话</li>
<li>Session getSession(SessionKey key) throws SessionException; //根据会话 Key 获取会话</li>
</ul>
<p>Shiro 提供了三个默认实现：</p>
<ul>
<li>DefaultSessionManager：DefaultSecurityManager 使用的默认实现，用于 JavaSE 环境；</li>
<li>ServletContainerSessionManager：DefaultWebSecurityManager 使用的默认实现，用于Web环境，其直接使用 Servlet 容器的会话；</li>
<li>DefaultWebSessionManager：用于Web环境的实现，可以替代 ServletContainerSessionManager，自己维护着会话，直接废弃了 Servlet 容器的会话管理。</li>
</ul>
<p>另外可以设置会话的全局过期时间（毫秒为单位），默认 30 分钟：sessionManager. globalSessionTimeout=1800000</p>
<p>另外如果使用 ServletContainerSessionManager 进行会话管理，Session 的超时依赖于底层 Servlet 容器的超时时间，可以在 web.xml 中配置其会话的超时时间（分钟为单位）：</p>
<pre><code>&lt;session-config&gt;
&lt;session-timeout&gt;30&lt;/session-timeout&gt;
&lt;/session-config&gt;
</code></pre><p>从SecurityUtils.getSubject()一步步detect，感受一下session是如何设置到subject中的。</p>
<p>判断线程context中是否存在Subject后，若不存在，我们使用Subject的内部类Builder进行buildSubject();</p>
<pre><code>public static Subject getSubject() {
    Subject subject = ThreadContext.getSubject();
    if (subject == null) {
        subject = (new Subject.Builder()).buildSubject();
        ThreadContext.bind(subject);
    }
    return subject;
}
</code></pre><p>buildSubject()将建立Subject的工作委托给securityManager.createSubject(subjectContext)</p>
<p>createSubject会调用resolveSession处理session。</p>
<pre><code>protected SubjectContext resolveSession(SubjectContext context) {
    if (context.resolveSession() != null) {
        log.debug(&quot;Context already contains a session.  Returning.&quot;);
        return context;
    }
    try {
        //Context couldn&apos;t resolve it directly, let&apos;s see if we can since we have direct access to
        //the session manager:
        Session session = resolveContextSession(context);
        if (session != null) {
            context.setSession(session);
        }
    } catch (InvalidSessionException e) {
        log.debug(&quot;Resolved SubjectContext context session is invalid.  Ignoring and creating an anonymous &quot; +
                &quot;(session-less) Subject instance.&quot;, e);
    }
    return context;
}
</code></pre><p>resolveSession(subjectContext)–首先尝试从context(MapContext)中获取session，如果无法直接获取则改为获取subject，再调用其getSession(false)。</p>
<p>如果仍不存在则调用resolveContextSession(subjectContext)，试着从MapContext中获取sessionId。</p>
<p>从 content中获取SessionKey,根据 sessionId实例化一个 SessionKey对象，并通过 SessionKey实例获取 session。</p>
<p>getSession(key)的任务直接交给sessionManager来执行。</p>
<pre><code>public Session getSession(SessionKey key) throws SessionException {
    return this.sessionManager.getSession(key);
}
</code></pre><p>sessionManager.getSession(key)方法在AbstractNativeSessionManager中定义，该方法调用lookupSession(key)，</p>
<p>lookupSession调用doGetSession(key)，doGetSession(key)是个protected abstract，实现由子类AbstractValidatingSessionManager提供。</p>
<p>doGetSession调用retrieveSession(key)，根据key获取sessionId,如果sessionId为null,则直接返回session为null;<br>如果sessionId不为null,则该方法尝试通过sessionDAO获得session信息。</p>
<p>最后，判断session是否为空后对其进行验证(参考SimpleSession.validate())。</p>
<pre><code>protected final Session doGetSession(final SessionKey key) throws InvalidSessionException {
    enableSessionValidationIfNecessary();

    log.trace(&quot;Attempting to retrieve session with key {}&quot;, key);

    Session s = retrieveSession(key);
    if (s != null) {
        validate(s, key);//验证这个key对应的session是否有效
    }
    return s;
}
</code></pre><h3 id="会话监听器"><a href="#会话监听器" class="headerlink" title="会话监听器"></a>会话监听器</h3><p>会话监听器用于监听会话创建、过期及停止事件。可以实现SessionListener中的onStart、onExpiration、onStop方法:</p>
<pre><code>public interface SessionListener {

    void onStart(Session session);

    void onStop(Session session);

    void onExpiration(Session session);
}
</code></pre><h3 id="会话存储-持久化"><a href="#会话存储-持久化" class="headerlink" title="会话存储/持久化"></a>会话存储/持久化</h3><p>Shiro 提供 SessionDAO 用于会话的 CRUD，即 DAO（Data Access Object）模式实现</p>
<pre><code>-- SessionDAO
    -- AbstractSessionDAO
        -- CachingSessionDAO
            -- EnterpriseCacheSessionDAO
        -- MemorySessionDAO
</code></pre><ul>
<li>AbstractSessionDAO：在create和read时对session做验证，保证session可用，并提供了sessionId的生成方法。</li>
<li>CachingSessionDAO：为session存储提供透明的缓存支持，使用CacheManager维护缓存。</li>
<li>EnterpriseCacheSessionDAO：通过匿名内部类重写了AbstractCacheManager的createCache，返回MapCache对象。</li>
<li>MemorySessionDAO：基于内存的实现，所有会话放在内存中。</li>
</ul>
<p>比如将session存储到redis中,那么我们实现AbstractSessionDAO接口重写里面的一些update(Session session),delete(Session session),getActiveSessions(),doCreate(Session session) ,doReadSession(Serializable sessionId)等方法即可</p>
<h2 id="在WEb应用中还需要进行web-xml的配置"><a href="#在WEb应用中还需要进行web-xml的配置" class="headerlink" title="在WEb应用中还需要进行web.xml的配置"></a>在WEb应用中还需要进行web.xml的配置</h2><p>在最开始就设置shiro的过滤器,让一定的请求经过这个过滤器,进行权限判断</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre><h2 id="spring-shiro-xml的一些配置"><a href="#spring-shiro-xml的一些配置" class="headerlink" title="spring-shiro.xml的一些配置"></a>spring-shiro.xml的一些配置</h2><p>主要配置:</p>
<pre><code>&lt;!--安全管理器--&gt;
&lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;
    &lt;property name=&quot;realm&quot; ref=&quot;myAuthorizingRealm&quot;/&gt;
&lt;/bean&gt;
&lt;!--自定义域--&gt;
&lt;bean id=&quot;myAuthorizingRealm&quot; class=&quot;uyun.bird.portal.shiro.MyAuthorizingRealm&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;myAuthorizingRealm&quot;/&gt;
    &lt;property name=&quot;authorizationCacheName&quot; value=&quot;shiro.authorizationCache&quot;/&gt;
    &lt;property name=&quot;credentialsMatcher&quot;&gt;
        &lt;bean class=&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt;
            &lt;property name=&quot;hashAlgorithmName&quot; value=&quot;MD5&quot;/&gt;
            &lt;property name=&quot;storedCredentialsHexEncoded&quot; value=&quot;true&quot;/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;!--过滤器--&gt;
&lt;!--Web应用中,Shiro可控制的Web请求必须经过Shiro主过滤器的拦截,Shiro对基于Spring的Web应用提供了完美的支持--&gt;
&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;
    &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;
    &lt;property name=&quot;loginUrl&quot; value=&quot;/opercentre/index.html#/login&quot;/&gt;
    &lt;!--
    &lt;property name=&quot;successUrl&quot; value=&quot;/s/index&quot;/&gt;
    &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/s/unauthorized&quot;/&gt;
     --&gt;
    &lt;property name=&quot;filters&quot;&gt;
        &lt;util:map&gt;
            &lt;entry key=&quot;codeValidate&quot; value-ref=&quot;codeAuthenticationFilter&quot;/&gt;
        &lt;/util:map&gt;
    &lt;/property&gt;
    &lt;property name=&quot;filterChainDefinitions&quot;&gt;
        &lt;value&gt;
            /** = anon &lt;!--# 游客(匿名) authc需要验证--&gt;
        &lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><h3 id="Shiro内置的FilterChain"><a href="#Shiro内置的FilterChain" class="headerlink" title="Shiro内置的FilterChain"></a>Shiro内置的FilterChain</h3><ol>
<li>Shiro验证URL时,URL匹配成功便不再继续匹配查找(所以要注意配置文件中的URL顺序,尤其在使用通配符时),故filterChainDefinitions的配置顺序为自上而下,以最上面的为准</li>
<li>当运行一个Web应用程序时,Shiro将会创建一些有用的默认Filter实例,并自动地在spring配置项中将它们置为可用自动地可用的默认的Filter实例是被DefaultFilter枚举类定义的,枚举的名称字段就是可供配置的名称</li>
<li>通常可将这些过滤器分为两组<br>anon,authc,authcBasic,user是第一组认证过滤器<br>perms,port,rest,roles,ssl是第二组授权过滤器<br>注意user和authc不同：当应用开启了rememberMe时,用户下次访问时可以是一个user,但绝不会是authc,因为authc是需要重新认证的user表示用户不一定已通过认证,只要曾被Shiro记住过登录状态的用户就可以正常发起请求,比如rememberMe<br>说白了,以前的一个用户登录时开启了rememberMe,然后他关闭浏览器,下次再访问时他就是一个user,而不会authc</li>
<li>举几个例子<ul>
<li>/admin=authc,roles[admin]      表示用户必需已通过认证,并拥有admin角色才可以正常发起’/admin’请求</li>
<li>/edit=authc,perms[admin:edit]  表示用户必需已通过认证,并拥有admin:edit权限才可以正常发起’/edit’请求</li>
<li>/home=user                     表示用户不一定需要已经通过认证,只需要曾经被Shiro记住过登录状态就可以正常发起’/home’请求</li>
</ul>
</li>
<li>各默认过滤器常用如下(注意URL Pattern里用到的是两颗星,这样才能实现任意层次的全匹配)<ul>
<li>/admins/**=anon             无参,表示可匿名使用,可以理解为匿名用户或游客</li>
<li>/admins/user/**=authc       无参,表示需认证才能使用</li>
<li>/admins/user/**=authcBasic  无参,表示httpBasic认证</li>
<li>/admins/user/**=user        无参,表示必须存在用户,当登入操作时不做检查  </li>
<li>/admins/user/**=ssl         无参,表示安全的URL请求,协议为https</li>
<li>/admins/user/<strong>=perms[user:add:*] 参数可写多个,多参时必须加上引号,且参数之间用逗号分割,如/admins/user/</strong>=perms[“user:add:<em>,user:modify:</em>“],当有多个参数时必须每个参数都通过才算通过,相当于isPermitedAll()方法</li>
<li>/admins/user/**=port[8081] 当请求的URL端口不是8081时,跳转到schemal://serverName:8081?queryString,其中schmal是协议http或https等,serverName是你访问的Host,8081是Port端口,queryString是你访问的URL里的?后面的参数</li>
<li>/admins/user/<strong>=rest[user] 根据请求的方法,相当于/admins/user/</strong>=perms[user:method],其中method为post,get,delete等</li>
<li>/admins/user/<strong>=roles[admin] 参数可写多个,多个时必须加上引号,且参数之间用逗号分割,如/admins/user/</strong>=roles[“admin,guest”],当有多个参数时必须每个参数都通过才算通过,相当于hasAllRoles()方法</li>
</ul>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;shiro认识&quot;&gt;&lt;a href=&quot;#shiro认识&quot; class=&quot;headerlink&quot; title=&quot;shiro认识&quot;&gt;&lt;/a&gt;shiro认识&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;shiro是Apache出的一个Java安全框架,提供了认证,授权,加密,会话管理,web集成和缓存等功能.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://dl2.iteye.com/upload/attachment/0093/9788/d59f6d02-1f45-3285-8983-4ea5f18111d5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://github.com/chenfeifeng/chenfeifeng.github.io.git/categories/java/"/>
    
    
      <category term="shiro" scheme="https://github.com/chenfeifeng/chenfeifeng.github.io.git/tags/shiro/"/>
    
  </entry>
  
  <entry>
    <title>Markdown测试</title>
    <link href="https://github.com/chenfeifeng/chenfeifeng.github.io.git/2016/08/15/markdowntest/"/>
    <id>https://github.com/chenfeifeng/chenfeifeng.github.io.git/2016/08/15/markdowntest/</id>
    <published>2016-08-14T16:25:48.000Z</published>
    <updated>2016-08-28T15:26:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><blockquote>
<p>这里是引用</p>
</blockquote>
<p><a href="http://share.renren.com/share/343913831/15031456744" target="_blank" rel="external">超链接</a><br><img src="http://cdn.sspai.com/attachment/thumbnail/2014/04/15/f96c892fc63933ab186235f7c910753b10f77_mw_800_wm_1_wmp_3.jpg" alt=""></p>
<a id="more"></a>
<p><strong>这个是</strong><br><em>斜体</em></p>
<h2 id="下面是表格"><a href="#下面是表格" class="headerlink" title="下面是表格"></a>下面是表格</h2><table>
<thead>
<tr>
<th>Tables</th>
<th style="text-align:center">Are</th>
<th style="text-align:right">Cool</th>
</tr>
</thead>
<tbody>
<tr>
<td>col 3 is</td>
<td style="text-align:center">right-aligned</td>
<td style="text-align:right">$1600</td>
</tr>
<tr>
<td>col 2 is</td>
<td style="text-align:center">centered</td>
<td style="text-align:right">$12</td>
</tr>
<tr>
<td>zebra stripes</td>
<td style="text-align:center">are neat</td>
<td style="text-align:right">$1</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">tables</th>
<th>row1</th>
<th style="text-align:right">row2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">:-:中间对齐</td>
<td>-左对齐</td>
<td style="text-align:right">-:右对齐</td>
</tr>
</tbody>
</table>
<p>分割线  </p>
<hr>
<h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><p><code>private void test(){
    System.out.println(&quot;这是一个测试!!!&quot;)
}</code></p>
<h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre><code>private static void test(){
      sadsad按时大大说
}
</code></pre><p>内联方式：This is an <a href="http://example.com/" target="_blank" rel="external">example link</a>.</p>
<p>引用方式：<br>I get 10 times more traffic from <a href="http://google.com/" title="Google" target="_blank" rel="external">Google</a> than from <a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="external">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="external">MSN</a>.</p>
<p>内联方式：<img src="http://cdn.sspai.com/attachment/thumbnail/2014/04/15/f96c892fc63933ab186235f7c910753b10f77_mw_800_wm_1_wmp_3.jpg" alt="alt text"></p>
<p>引用方式：<br><img src="http://cdn.sspai.com/attachment/thumbnail/2014/04/15/f96c892fc63933ab186235f7c910753b10f77_mw_800_wm_1_wmp_3.jpg" alt="alt text"> </p>
<ol>
<li>脚注（footnote）实现方式如下：hello<a href="hi">^hello</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一级标题&quot;&gt;&lt;a href=&quot;#一级标题&quot; class=&quot;headerlink&quot; title=&quot;一级标题&quot;&gt;&lt;/a&gt;一级标题&lt;/h1&gt;&lt;h2 id=&quot;二级标题&quot;&gt;&lt;a href=&quot;#二级标题&quot; class=&quot;headerlink&quot; title=&quot;二级标题&quot;&gt;&lt;/a&gt;二级标题&lt;/h2&gt;&lt;h3 id=&quot;三级标题&quot;&gt;&lt;a href=&quot;#三级标题&quot; class=&quot;headerlink&quot; title=&quot;三级标题&quot;&gt;&lt;/a&gt;三级标题&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;这里是引用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://share.renren.com/share/343913831/15031456744&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;超链接&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;http://cdn.sspai.com/attachment/thumbnail/2014/04/15/f96c892fc63933ab186235f7c910753b10f77_mw_800_wm_1_wmp_3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Testing" scheme="https://github.com/chenfeifeng/chenfeifeng.github.io.git/categories/Testing/"/>
    
    
      <category term="Markdown" scheme="https://github.com/chenfeifeng/chenfeifeng.github.io.git/tags/Markdown/"/>
    
  </entry>
  
</feed>
