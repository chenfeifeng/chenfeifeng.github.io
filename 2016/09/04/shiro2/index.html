<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="shiro," />





  <link rel="alternate" href="/atom.xml" title="九客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="shiro认识简介shiro是Apache出的一个Java安全框架,提供了认证,授权,加密,会话管理,web集成和缓存等功能.">
<meta name="keywords" content="shiro">
<meta property="og:type" content="article">
<meta property="og:title" content="shiro">
<meta property="og:url" content="https://github.com/chenfeifeng/chenfeifeng.github.io.git/2016/09/04/shiro2/index.html">
<meta property="og:site_name" content="九客">
<meta property="og:description" content="shiro认识简介shiro是Apache出的一个Java安全框架,提供了认证,授权,加密,会话管理,web集成和缓存等功能.">
<meta property="og:image" content="http://dl2.iteye.com/upload/attachment/0093/9788/d59f6d02-1f45-3285-8983-4ea5f18111d5.png">
<meta property="og:image" content="http://fh-1.qiniudn.com/shiro/shiro-core.png">
<meta property="og:image" content="http://fh-1.qiniudn.com/shiro/Shiro-AuthorizationSequence.png">
<meta property="og:updated_time" content="2016-09-06T14:47:18.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="shiro">
<meta name="twitter:description" content="shiro认识简介shiro是Apache出的一个Java安全框架,提供了认证,授权,加密,会话管理,web集成和缓存等功能.">
<meta name="twitter:image" content="http://dl2.iteye.com/upload/attachment/0093/9788/d59f6d02-1f45-3285-8983-4ea5f18111d5.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="https://github.com/chenfeifeng/chenfeifeng.github.io.git/2016/09/04/shiro2/"/>

  <title> shiro | 九客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">九客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">一天进步一点</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                shiro
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-04T16:06:45+08:00" content="2016-09-04">
              2016-09-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="shiro认识"><a href="#shiro认识" class="headerlink" title="shiro认识"></a>shiro认识</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>shiro是Apache出的一个Java安全框架,提供了认证,授权,加密,会话管理,web集成和缓存等功能.</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0093/9788/d59f6d02-1f45-3285-8983-4ea5f18111d5.png" alt=""></p>
<a id="more"></a>
<p>Authentication：身份认证/登录，验证用户是不是拥有相应的身份；</p>
<p>Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</p>
<p>Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的；</p>
<p>Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</p>
<p>Web Support：Web支持，可以非常容易的集成到Web环境；</p>
<p>Caching：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；</p>
<p>Concurrency：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</p>
<p>Testing：提供测试支持；</p>
<p>Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</p>
<p>Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</p>
<h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p>Shiro的三个核心组件：Subject, SecurityManager 和 Realms. 如下图：<br><img src="http://fh-1.qiniudn.com/shiro/shiro-core.png" alt=""></p>
<h3 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h3><p>即“当前操作用户”。但是，在Shiro中，Subject这一概念并不仅仅指人，也可以是第三方进程、后台帐户（Daemon Account）或其他类似事物。它仅仅意味着“当前跟软件交互的东西”。但考虑到大多数目的和用途，你可以把它认为是Shiro的“用户”概念。Subject代表了当前用户的安全操作，SecurityManager则管理所有用户的安全操作。与Subject的所有交互都会委托给SecurityManager。</p>
<h3 id="SecurityManager"><a href="#SecurityManager" class="headerlink" title="SecurityManager"></a>SecurityManager</h3><p>安全管理器；即所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject；可以看出它是Shiro的核心，它负责与后边介绍的其他组件进行交互，如果学习过SpringMVC，你可以把它看成DispatcherServlet前端控制器；</p>
<h3 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h3><p>Realm充当了Shiro与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。从这个意义上讲，Realm实质上是一个安全相关的DAO：它封装了数据源的连接细节，并在需要时将相关数据提供给Shiro。当配置Shiro时，你必须至少指定一个Realm，用于认证和（或）授权。配置多个Realm是可以的，但是至少需要一个。Shiro内置了可以连接大量安全数据源（又名目录）的Realm，如LDAP、关系数据库（JDBC）、类似INI的文本配置资源以及属性文件等。如果缺省的Realm不能满足需求，你还可以插入代表自定义数据源的自己的Realm实现。</p>
<p>也就是说对于我们而言，最简单的一个Shiro应用：</p>
<p>1、应用代码通过Subject来进行认证和授权，而Subject又委托给SecurityManager；</p>
<p>2、我们需要给Shiro的SecurityManager注入Realm，从而让SecurityManager能得到合法的用户及其权限进行判断。</p>
<p>从以上也可以看出，Shiro不提供维护用户/权限，而是通过Realm让开发人员自己注入(即需要我们自己管理Realm)。</p>
<h2 id="shiro的使用"><a href="#shiro的使用" class="headerlink" title="shiro的使用"></a>shiro的使用</h2><h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><p>认证就是验证用户身份的过程。在认证过程中，用户需要提交实体信息(Principals)和凭据信息(Credentials)以检验用户是否合法。最常见的“实体/凭证”组合便是“用户名/密码”组合。</p>
<pre><code>AuthenticationToken token = new UsernamePasswordToken(
  operUser.getOperUserName(), operUser.getPassWord());
Subject subject = SecurityUtils.getSubject();
try {
    subject.login(token);
    if (!subject.isAuthenticated()) {
        return new RespContent(&quot;400&quot;, &quot;用户认证失败！&quot;);
    }
} catch (UnknownAccountException uae) {
      log.info(&quot;There is no user with username of &quot; + token.getPrincipal());
} catch (IncorrectCredentialsException ice) {
      log.info(&quot;Password for account &quot; + token.getPrincipal() + &quot; was incorrect!&quot;);
} catch (LockedAccountException lae) {
      log.info(&quot;The account for username &quot; + token.getPrincipal() + &quot; is locked. &quot; +
       &quot;Please contact your administrator to unlock it.&quot;);
}
// ... 捕获更多异常
catch (AuthenticationException ae) {
      // 无定义错误?
}
//完成 - 退出t!
subject.logout();
</code></pre><p>身份验证的主要流程就是：</p>
<ul>
<li>收集用户身份/凭证，即如用户名/密码；</li>
<li>调用 Subject.login 进行登录，如果失败将得到相应的 AuthenticationException 异常，根<br>据异常提示用户错误信息；否则登录成功；</li>
<li>最后调用 Subject.logout 进行退出操作。</li>
</ul>
<h4 id="—收集信息"><a href="#—收集信息" class="headerlink" title="—收集信息"></a>—收集信息</h4><p>UsernamePasswordToken支持最常见的用户名/密码的认证机制。同时，由于它实现了RememberMeAuthenticationToken接口，我们可以通过令牌设置“记住我”的功能。但是，“已记住”和“已认证”是有区别的：已记住的用户仅仅是非匿名用户，你可以通过subject.getPrincipals()获取用户信息。但是它并非是完全认证通过的用户，当你访问需要认证用户的功能时，你仍然需要重新提交认证信息。这一区别可以参考亚马逊网站，网站会默认记住登录的用户，再次访问网站时，对于非敏感的页面功能，页面上会显示记住的用户信息，但是当你访问网站账户信息时仍然需要再次进行登录认证。 subject.isAuthenticated()和subject.isRemembered()的值总是相反的。</p>
<h4 id="—认证处理"><a href="#—认证处理" class="headerlink" title="—认证处理"></a>—认证处理</h4><p>如果login方法执行完毕且没有抛出任何异常信息，那么便认为用户认证通过。之后在应用程序任意地方调用SecurityUtils.getSubject() 都可以获取到当前认证通过的用户实例，使用subject.isAuthenticated()判断用户是否已验证都将返回true. 相反，如果login方法执行过程中抛出异常，那么将认为认证失败。Shiro有着丰富的层次鲜明的异常类来描述认证失败的原因，如代码示例。</p>
<h4 id="—登出操作"><a href="#—登出操作" class="headerlink" title="—登出操作"></a>—登出操作</h4><pre><code>Subject subject = SecurityUtils.getSubject();
subject.logout();
</code></pre><p>源码如下:</p>
<pre><code>//清空了session中的登录信息,subject将被视作为匿名用户
public void logout() {
    try {
      clearRunAsIdentitiesInternal();//清楚内部身份信息清楚session
      this.securityManager.logout(this);//删除当前subject信息
      this.session = null;
      this.principals = null;
      this.authenticated = false;
    } finally {
      this.session = null;
      this.principals = null;
      this.authenticated = false;
    }
}
</code></pre><h3 id="Realm的实现"><a href="#Realm的实现" class="headerlink" title="Realm的实现"></a>Realm的实现</h3><pre><code>public class MyAuthorizingRealm extends AuthorizingRealm {
    //在有权限验证的时候进入,进行权限获取
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
        if (principals == null) {
            throw new AuthorizationException(&quot;PrincipalCollection method
            argument cannot be null.&quot;);
        }
        String username = (String) getAvailablePrincipal(principals);
        Set&lt;String&gt; roleNames = new HashSet&lt;&gt;();
        Set&lt;String&gt; permissions = new HashSet&lt;&gt;();
        // 获取权限和角色存入SimpleAuthorizationInfo中
        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(roleNames);
        info.setStringPermissions(permissions);
        return info;
    }

    //首次登录时进行subject的信息存储
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token)
    throws AuthenticationException {
        UsernamePasswordToken upToken = (UsernamePasswordToken) token;
        String username = upToken.getUsername();
        if (username == null) {
            throw new AccountException(&quot;Null usernames are not allowed by this realm.&quot;);
        }

        OpercentreUser user = opercentreUserService.getLoginOperUser(username);
        if (user == null) {
          throw new UnknownAccountException(&quot;No account found for user [&quot; + username + &quot;]&quot;);
        }

        String password = user.getPassWord();

        if (password == null) {
            throw new UnknownAccountException(&quot;No account found for user [&quot; + username + &quot;]&quot;);
        }

        SimpleAuthenticationInfo saInfo = new SimpleAuthenticationInfo(username,
          password, getName());
        saInfo.setCredentialsSalt(ByteSource.Util.bytes(user.getSalt()));
        return saInfo;
    }
}
</code></pre><p>一般继承AuthorizingRealm即可，需要实现getAuthenticationInfo(AuthenticationToken token)和doGetAuthenticationInfo(PrincipalCollection principals)两个方法</p>
<h3 id="多个Realm认证"><a href="#多个Realm认证" class="headerlink" title="多个Realm认证"></a>多个Realm认证</h3><p>shiro也可以有多个Realm的认证:</p>
<pre><code>&lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;  
    &lt;!-- 其他配置 --&gt;  
    &lt;property name=&quot;authenticator&quot; ref=&quot;authenticator&quot; /&gt;  
    &lt;property name=&quot;realms&quot;&gt;  
        &lt;list&gt;  
            &lt;ref bean=&quot;defaultJdbcRealm&quot; /&gt;  
            &lt;ref bean=&quot;backDoorJdbcRealm&quot; /&gt;  
        &lt;/list&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;
&lt;bean id=&quot;defaultJdbcRealm&quot; class=&quot;...&quot; /&gt;  
&lt;bean id=&quot;backDoorJdbcRealm&quot; class=&quot;...&quot; /&gt;
&lt;bean id=&quot;authenticator&quot; class=&quot;xxx.yyy.security.ModularRealmAuthenticator&quot;&gt;  
    &lt;property name=&quot;authenticationStrategy&quot;&gt;  
        &lt;bean class=&quot;org.apache.shiro.authc.pam.FirstSuccessfulStrategy&quot; /&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;  
</code></pre><p>多个Realm的时候可以定义认证策略authenticationStrategy:</p>
<ul>
<li>AtLeastOneSuccessfulStrategy 只要有一个（或更多）的Realm验证成功，那么认证将被视为成功</li>
<li>FirstSuccessfulStrategy 第一个Realm验证成功，整体认证将被视为成功，且后续Realm将被忽略</li>
<li>AllSuccessfulStrategy 所有Realm成功，认证才视为成功</li>
</ul>
<p>ModularRealmAuthenticator 内置的认证策略默认实现是AtLeastOneSuccessfulStrategy 方式，因为这种方式也是被广泛使用的一种认证策略</p>
<h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>授权有着三个核心元素：权限(permissions)、角色(roles)和用户(users)。</p>
<p>Shiro支持三种方式实现授权过程：</p>
<ul>
<li>编码实现：if(subject.hasRole(“admin”)){//有权限}</li>
<li>注解实现：@RequiresRoles(“admin”)public void hello() {//有权限}</li>
<li>JSP Taglig实现：<shiro:hasrole name="admin">&lt;!— 有权限 —&gt;</shiro:hasrole></li>
</ul>
<p>使用注解进行权限控制:(开启注解和spring的类似)</p>
<pre><code>&lt;bean class=&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt;
</code></pre><p>   <property name="securityManager" ref="securityManager"><br>    </property></p>
<p>注解类型:</p>
<p>@RequiresAuthentication:要求当前Subject 已经在当前的session 中被验证通过才能被访问或调用.</p>
<p>@RequiresGuest:要求当前的Subject 是一个”guest”，也就是说，他们必须是在之前的session 中没有被验证或被记住才能被访问或调用.</p>
<p>@RequiresPermissions(“权限”):要求当前的Subject 被允许一个或多个权限，以便执行注解的方法.</p>
<pre><code>subject.isPermitted(&quot;权限&quot;)
</code></pre><p>@RequiresRoles(“角色”):要求当前的Subject 拥有所有指定的角色。如果他们没有，则该方法将不会被执行，而且AuthorizationException 异常将会被抛出.</p>
<pre><code>subject.hasRole(&quot;角色&quot;)
</code></pre><p>以上权限配置如果未通过会直接抛异常,AuthorizationException(授权异常)和UnauthenticatedException(验证异常)最为多见,可以自己spring全局异常捕捉控制.</p>
<p>Shiro还支持以断言的方式进行授权验证。断言成功，不返回任何值，程序继续执行；断言失败时，将抛出异常信息。<br>比如subject.checkRole(String roleName)和subject.checkPermission(String permission)授权处理过程中：</p>
<ol>
<li>当调用Realm出现异常时，将立即抛出异常，结束授权验证。</li>
<li>只要有一个Realm验证成功，那么将认为授权成功，立即返回，结束认证。</li>
</ol>
<h3 id="基于JSP-TAG的授权实现"><a href="#基于JSP-TAG的授权实现" class="headerlink" title="基于JSP TAG的授权实现"></a>基于JSP TAG的授权实现</h3><p>Shiro提供了一套JSP标签库来实现页面级的授权控制。标签库描述文件 (TLD)被打包在 META-INF/shiro.tld 文件中的 shiro-web.jar 文件中。</p>
<p>在使用Shiro标签库前，首先需要在JSP引入shiro标签：</p>
<pre><code>&lt;%@ taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;
</code></pre><p>下面一一介绍Shiro的标签：</p>
<p>guest标签:验证当前用户是否为“访客”，即未认证（包含未记住）的用户</p>
<pre><code>&lt;shiro:guest&gt;
    Hi there!  Please &lt;a href=&quot;login.jsp&quot;&gt;Login&lt;/a&gt; or &lt;a href=&quot;signup.jsp&quot;&gt;Signup&lt;/a&gt; today!
&lt;/shiro:guest&gt;
</code></pre><p>user标签:认证通过或已记住的用户</p>
<pre><code>&lt;shiro:user&gt;  
    Welcome back John!  Not John? Click &lt;a href=&quot;login.jsp&quot;&gt;here&lt;a&gt; to login.  
&lt;/shiro:user&gt;
</code></pre><p>authenticated标签:已认证通过的用户。不包含已记住的用户，这是与user标签的区别所在。</p>
<pre><code>&lt;shiro:authenticated&gt;  
    &lt;a href=&quot;updateAccount.jsp&quot;&gt;Update your contact information&lt;/a&gt;.  
&lt;/shiro:authenticated&gt;
</code></pre><p>notAuthenticated标签:未认证通过用户，与authenticated标签相对应。与guest标签的区别是，该标签包含已记住用户。</p>
<pre><code>&lt;shiro:notAuthenticated&gt;  
    Please &lt;a href=&quot;login.jsp&quot;&gt;login&lt;/a&gt; in order to update
    your credit card information.  
&lt;/shiro:notAuthenticated&gt;
</code></pre><p>hasRole标签:验证当前用户是否属于该角色</p>
<pre><code>&lt;shiro:hasRole name=&quot;administrator&quot;&gt;  
    &lt;a href=&quot;admin.jsp&quot;&gt;Administer the system&lt;/a&gt;  
&lt;/shiro:hasRole&gt;
</code></pre><p>lacksRole标签:与hasRole标签逻辑相反，当用户不属于该角色时验证通过</p>
<pre><code>&lt;shiro:lacksRole name=&quot;administrator&quot;&gt;  
    Sorry, you are not allowed to administer the system.  
&lt;/shiro:lacksRole&gt;
</code></pre><p>hasAnyRole标签:验证当前用户是否属于以下任意一个角色。</p>
<pre><code>&lt;shiro:hasAnyRoles name=&quot;developer, project manager, administrator&quot;&gt;  
    You are either a developer, project manager, or administrator.  
&lt;/shiro:lacksRole&gt;
</code></pre><p>hasPermission标签:验证当前用户是否拥有制定权限</p>
<pre><code>&lt;shiro:hasPermission name=&quot;user:create&quot;&gt;  
    &lt;a href=&quot;createUser.jsp&quot;&gt;Create a new User&lt;/a&gt;  
&lt;/shiro:hasPermission&gt;
</code></pre><p>lacksPermission标签:与hasPermission标签逻辑相反，当前用户没有制定权限时，验证通过</p>
<pre><code>&lt;shiro:hasPermission name=&quot;user:create&quot;&gt;  
    &lt;a href=&quot;createUser.jsp&quot;&gt;Create a new User&lt;/a&gt;  
&lt;/shiro:hasPermission&gt;
</code></pre><h3 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h3><p><img src="http://fh-1.qiniudn.com/shiro/Shiro-AuthorizationSequence.png" alt=""></p>
<ol>
<li>程序或框架代码调用一个 Subject 的hasRole<em>、checkRole</em>、isPermitted<em>或者checkPermission</em>方法，传递所需的权限或角色。</li>
<li>Subject实例，通常是一个 DelegatingSubject（或子类），通过调用securityManager 与各 hasRole<em>、checkRole</em>、isPermitted<em>或checkPermission</em> 基本一致的方法将权限或角色传递给程序的 SecurityManager(实现了 org.apache.shiro.authz.Authorizer 接口)。</li>
<li>接下来SecurityManager会委托内置的Authorizer的实例（默认是ModularRealmAuthorizer 类的实例，类似认证实例，它同样支持一个或多个Realm实例认证）调用相应的授权方法。</li>
<li>每一个Realm将检查是否实现了相同的 Authorizer 接口。然后，将调用Reaml自己的相应的授权验证方法。</li>
</ol>
<p>在认证、授权内部实现机制中都有提到，最终处理都将交给Realm进行处理。因为在Shiro中，最终是通过Realm来获取应用程序中的用户、角色及权限信息的。通常情况下，在Realm中会直接从我们的数据源中获取Shiro需要的验证信息。可以说，Realm是专用于安全框架的DAO.</p>
<h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><p>Shiro 提供了完整的企业级会话管理功能，不依赖于底层容器（如 web 容器 tomcat），不管JavaSE 还是 JavaEE 环境都可以使用，提供了会话管理、会话事件监听、会话存储/持久化、容器无关的集群、失效/过期支持、对 Web 的透明支持、SSO 单点登录的支持等特性。</p>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>登录成功后使用 Subject.getSession()即可获取会话；其等价于 Subject.getSession(true)，即如果当前没有创建 Session 对象会创建一个；另外 Subject.getSession(false)，如果当前没有创建 Session 则返回 null</p>
<ul>
<li>session.getId(); //获取会话唯一标识</li>
<li>session.getHost(); //获取 Subject的主机地址,该地址是通过 HostAuthenticationToken.getHost()提供的</li>
<li>session.getTimeout(); //获取过期时间</li>
<li>session.setTimeout(毫秒); //设置会话过期时间</li>
<li>session.getStartTimestamp(); //获取会话启动时间</li>
<li>session.getLastAccessTime(); //获取最后访问时间</li>
<li>session.touch(); //更新最后访问时间</li>
<li>session.stop(); //销毁会话。</li>
<li>session.setAttribute(“key”, “123”); //设置session属性</li>
<li>ession.getAttribute(“key”)); //获取session属性</li>
<li>session.removeAttribute(“key”); //删除会话属性</li>
</ul>
<h3 id="会话管理器"><a href="#会话管理器" class="headerlink" title="会话管理器"></a>会话管理器</h3><p>SessionManager，名如其意，在应用程序中为所有的 subject 管理Session —— 创建，删除，失效及验证，等等。如同其他在Shiro 中的核心结构组件一样，SessionManager 也是一个由 SecurityManager 维护的顶级组件。</p>
<ul>
<li>Session start(SessionContext context); //启动会话</li>
<li>Session getSession(SessionKey key) throws SessionException; //根据会话 Key 获取会话</li>
</ul>
<p>Shiro 提供了三个默认实现：</p>
<ul>
<li>DefaultSessionManager：DefaultSecurityManager 使用的默认实现，用于 JavaSE 环境；</li>
<li>ServletContainerSessionManager：DefaultWebSecurityManager 使用的默认实现，用于Web环境，其直接使用 Servlet 容器的会话；</li>
<li>DefaultWebSessionManager：用于Web环境的实现，可以替代 ServletContainerSessionManager，自己维护着会话，直接废弃了 Servlet 容器的会话管理。</li>
</ul>
<p>另外可以设置会话的全局过期时间（毫秒为单位），默认 30 分钟：sessionManager. globalSessionTimeout=1800000</p>
<p>另外如果使用 ServletContainerSessionManager 进行会话管理，Session 的超时依赖于底层 Servlet 容器的超时时间，可以在 web.xml 中配置其会话的超时时间（分钟为单位）：</p>
<pre><code>&lt;session-config&gt;
&lt;session-timeout&gt;30&lt;/session-timeout&gt;
&lt;/session-config&gt;
</code></pre><p>从SecurityUtils.getSubject()一步步detect，感受一下session是如何设置到subject中的。</p>
<p>判断线程context中是否存在Subject后，若不存在，我们使用Subject的内部类Builder进行buildSubject();</p>
<pre><code>public static Subject getSubject() {
    Subject subject = ThreadContext.getSubject();
    if (subject == null) {
        subject = (new Subject.Builder()).buildSubject();
        ThreadContext.bind(subject);
    }
    return subject;
}
</code></pre><p>buildSubject()将建立Subject的工作委托给securityManager.createSubject(subjectContext)</p>
<p>createSubject会调用resolveSession处理session。</p>
<pre><code>protected SubjectContext resolveSession(SubjectContext context) {
    if (context.resolveSession() != null) {
        log.debug(&quot;Context already contains a session.  Returning.&quot;);
        return context;
    }
    try {
        //Context couldn&apos;t resolve it directly, let&apos;s see if we can since we have direct access to
        //the session manager:
        Session session = resolveContextSession(context);
        if (session != null) {
            context.setSession(session);
        }
    } catch (InvalidSessionException e) {
        log.debug(&quot;Resolved SubjectContext context session is invalid.  Ignoring and creating an anonymous &quot; +
                &quot;(session-less) Subject instance.&quot;, e);
    }
    return context;
}
</code></pre><p>resolveSession(subjectContext)–首先尝试从context(MapContext)中获取session，如果无法直接获取则改为获取subject，再调用其getSession(false)。</p>
<p>如果仍不存在则调用resolveContextSession(subjectContext)，试着从MapContext中获取sessionId。</p>
<p>从 content中获取SessionKey,根据 sessionId实例化一个 SessionKey对象，并通过 SessionKey实例获取 session。</p>
<p>getSession(key)的任务直接交给sessionManager来执行。</p>
<pre><code>public Session getSession(SessionKey key) throws SessionException {
    return this.sessionManager.getSession(key);
}
</code></pre><p>sessionManager.getSession(key)方法在AbstractNativeSessionManager中定义，该方法调用lookupSession(key)，</p>
<p>lookupSession调用doGetSession(key)，doGetSession(key)是个protected abstract，实现由子类AbstractValidatingSessionManager提供。</p>
<p>doGetSession调用retrieveSession(key)，根据key获取sessionId,如果sessionId为null,则直接返回session为null;<br>如果sessionId不为null,则该方法尝试通过sessionDAO获得session信息。</p>
<p>最后，判断session是否为空后对其进行验证(参考SimpleSession.validate())。</p>
<pre><code>protected final Session doGetSession(final SessionKey key) throws InvalidSessionException {
    enableSessionValidationIfNecessary();

    log.trace(&quot;Attempting to retrieve session with key {}&quot;, key);

    Session s = retrieveSession(key);
    if (s != null) {
        validate(s, key);//验证这个key对应的session是否有效
    }
    return s;
}
</code></pre><h3 id="会话监听器"><a href="#会话监听器" class="headerlink" title="会话监听器"></a>会话监听器</h3><p>会话监听器用于监听会话创建、过期及停止事件。可以实现SessionListener中的onStart、onExpiration、onStop方法:</p>
<pre><code>public interface SessionListener {

    void onStart(Session session);

    void onStop(Session session);

    void onExpiration(Session session);
}
</code></pre><h3 id="会话存储-持久化"><a href="#会话存储-持久化" class="headerlink" title="会话存储/持久化"></a>会话存储/持久化</h3><p>Shiro 提供 SessionDAO 用于会话的 CRUD，即 DAO（Data Access Object）模式实现</p>
<pre><code>-- SessionDAO
    -- AbstractSessionDAO
        -- CachingSessionDAO
            -- EnterpriseCacheSessionDAO
        -- MemorySessionDAO
</code></pre><ul>
<li>AbstractSessionDAO：在create和read时对session做验证，保证session可用，并提供了sessionId的生成方法。</li>
<li>CachingSessionDAO：为session存储提供透明的缓存支持，使用CacheManager维护缓存。</li>
<li>EnterpriseCacheSessionDAO：通过匿名内部类重写了AbstractCacheManager的createCache，返回MapCache对象。</li>
<li>MemorySessionDAO：基于内存的实现，所有会话放在内存中。</li>
</ul>
<p>比如将session存储到redis中,那么我们实现AbstractSessionDAO接口重写里面的一些update(Session session),delete(Session session),getActiveSessions(),doCreate(Session session) ,doReadSession(Serializable sessionId)等方法即可</p>
<h2 id="在WEb应用中还需要进行web-xml的配置"><a href="#在WEb应用中还需要进行web-xml的配置" class="headerlink" title="在WEb应用中还需要进行web.xml的配置"></a>在WEb应用中还需要进行web.xml的配置</h2><p>在最开始就设置shiro的过滤器,让一定的请求经过这个过滤器,进行权限判断</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre><h2 id="spring-shiro-xml的一些配置"><a href="#spring-shiro-xml的一些配置" class="headerlink" title="spring-shiro.xml的一些配置"></a>spring-shiro.xml的一些配置</h2><p>主要配置:</p>
<pre><code>&lt;!--安全管理器--&gt;
&lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;
    &lt;property name=&quot;realm&quot; ref=&quot;myAuthorizingRealm&quot;/&gt;
&lt;/bean&gt;
&lt;!--自定义域--&gt;
&lt;bean id=&quot;myAuthorizingRealm&quot; class=&quot;uyun.bird.portal.shiro.MyAuthorizingRealm&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;myAuthorizingRealm&quot;/&gt;
    &lt;property name=&quot;authorizationCacheName&quot; value=&quot;shiro.authorizationCache&quot;/&gt;
    &lt;property name=&quot;credentialsMatcher&quot;&gt;
        &lt;bean class=&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt;
            &lt;property name=&quot;hashAlgorithmName&quot; value=&quot;MD5&quot;/&gt;
            &lt;property name=&quot;storedCredentialsHexEncoded&quot; value=&quot;true&quot;/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;!--过滤器--&gt;
&lt;!--Web应用中,Shiro可控制的Web请求必须经过Shiro主过滤器的拦截,Shiro对基于Spring的Web应用提供了完美的支持--&gt;
&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;
    &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;
    &lt;property name=&quot;loginUrl&quot; value=&quot;/opercentre/index.html#/login&quot;/&gt;
    &lt;!--
    &lt;property name=&quot;successUrl&quot; value=&quot;/s/index&quot;/&gt;
    &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/s/unauthorized&quot;/&gt;
     --&gt;
    &lt;property name=&quot;filters&quot;&gt;
        &lt;util:map&gt;
            &lt;entry key=&quot;codeValidate&quot; value-ref=&quot;codeAuthenticationFilter&quot;/&gt;
        &lt;/util:map&gt;
    &lt;/property&gt;
    &lt;property name=&quot;filterChainDefinitions&quot;&gt;
        &lt;value&gt;
            /** = anon &lt;!--# 游客(匿名) authc需要验证--&gt;
        &lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><h3 id="Shiro内置的FilterChain"><a href="#Shiro内置的FilterChain" class="headerlink" title="Shiro内置的FilterChain"></a>Shiro内置的FilterChain</h3><ol>
<li>Shiro验证URL时,URL匹配成功便不再继续匹配查找(所以要注意配置文件中的URL顺序,尤其在使用通配符时),故filterChainDefinitions的配置顺序为自上而下,以最上面的为准</li>
<li>当运行一个Web应用程序时,Shiro将会创建一些有用的默认Filter实例,并自动地在spring配置项中将它们置为可用自动地可用的默认的Filter实例是被DefaultFilter枚举类定义的,枚举的名称字段就是可供配置的名称</li>
<li>通常可将这些过滤器分为两组<br>anon,authc,authcBasic,user是第一组认证过滤器<br>perms,port,rest,roles,ssl是第二组授权过滤器<br>注意user和authc不同：当应用开启了rememberMe时,用户下次访问时可以是一个user,但绝不会是authc,因为authc是需要重新认证的user表示用户不一定已通过认证,只要曾被Shiro记住过登录状态的用户就可以正常发起请求,比如rememberMe<br>说白了,以前的一个用户登录时开启了rememberMe,然后他关闭浏览器,下次再访问时他就是一个user,而不会authc</li>
<li>举几个例子<ul>
<li>/admin=authc,roles[admin]      表示用户必需已通过认证,并拥有admin角色才可以正常发起’/admin’请求</li>
<li>/edit=authc,perms[admin:edit]  表示用户必需已通过认证,并拥有admin:edit权限才可以正常发起’/edit’请求</li>
<li>/home=user                     表示用户不一定需要已经通过认证,只需要曾经被Shiro记住过登录状态就可以正常发起’/home’请求</li>
</ul>
</li>
<li>各默认过滤器常用如下(注意URL Pattern里用到的是两颗星,这样才能实现任意层次的全匹配)<ul>
<li>/admins/**=anon             无参,表示可匿名使用,可以理解为匿名用户或游客</li>
<li>/admins/user/**=authc       无参,表示需认证才能使用</li>
<li>/admins/user/**=authcBasic  无参,表示httpBasic认证</li>
<li>/admins/user/**=user        无参,表示必须存在用户,当登入操作时不做检查  </li>
<li>/admins/user/**=ssl         无参,表示安全的URL请求,协议为https</li>
<li>/admins/user/<strong>=perms[user:add:*] 参数可写多个,多参时必须加上引号,且参数之间用逗号分割,如/admins/user/</strong>=perms[“user:add:<em>,user:modify:</em>“],当有多个参数时必须每个参数都通过才算通过,相当于isPermitedAll()方法</li>
<li>/admins/user/**=port[8081] 当请求的URL端口不是8081时,跳转到schemal://serverName:8081?queryString,其中schmal是协议http或https等,serverName是你访问的Host,8081是Port端口,queryString是你访问的URL里的?后面的参数</li>
<li>/admins/user/<strong>=rest[user] 根据请求的方法,相当于/admins/user/</strong>=perms[user:method],其中method为post,get,delete等</li>
<li>/admins/user/<strong>=roles[admin] 参数可写多个,多个时必须加上引号,且参数之间用逗号分割,如/admins/user/</strong>=roles[“admin,guest”],当有多个参数时必须每个参数都通过才算通过,相当于hasAllRoles()方法</li>
</ul>
</li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/shiro/" rel="tag">#shiro</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/15/markdowntest/" rel="next" title="Markdown测试">
                <i class="fa fa-chevron-left"></i> Markdown测试
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/06/12/shiro用户失效,简单控制方法的副本/" rel="prev" title="cglib动态代理实现">
                cglib动态代理实现 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/head1.JPG"
               alt="Joker_Chen" />
          <p class="site-author-name" itemprop="name">Joker_Chen</p>
          <p class="site-description motion-element" itemprop="description">鶸的成长记录~</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">4</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#shiro认识"><span class="nav-number">1.</span> <span class="nav-text">shiro认识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">1.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心组件"><span class="nav-number">1.2.</span> <span class="nav-text">核心组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Subject"><span class="nav-number">1.2.1.</span> <span class="nav-text">Subject</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SecurityManager"><span class="nav-number">1.2.2.</span> <span class="nav-text">SecurityManager</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Realm"><span class="nav-number">1.2.3.</span> <span class="nav-text">Realm</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shiro的使用"><span class="nav-number">1.3.</span> <span class="nav-text">shiro的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#身份验证"><span class="nav-number">1.3.1.</span> <span class="nav-text">身份验证</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#—收集信息"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">—收集信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#—认证处理"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">—认证处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#—登出操作"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">—登出操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Realm的实现"><span class="nav-number">1.3.2.</span> <span class="nav-text">Realm的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多个Realm认证"><span class="nav-number">1.3.3.</span> <span class="nav-text">多个Realm认证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#授权"><span class="nav-number">1.3.4.</span> <span class="nav-text">授权</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于JSP-TAG的授权实现"><span class="nav-number">1.3.5.</span> <span class="nav-text">基于JSP TAG的授权实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#授权流程"><span class="nav-number">1.3.6.</span> <span class="nav-text">授权流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#会话管理"><span class="nav-number">1.4.</span> <span class="nav-text">会话管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#会话"><span class="nav-number">1.4.1.</span> <span class="nav-text">会话</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#会话管理器"><span class="nav-number">1.4.2.</span> <span class="nav-text">会话管理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#会话监听器"><span class="nav-number">1.4.3.</span> <span class="nav-text">会话监听器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#会话存储-持久化"><span class="nav-number">1.4.4.</span> <span class="nav-text">会话存储/持久化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在WEb应用中还需要进行web-xml的配置"><span class="nav-number">1.5.</span> <span class="nav-text">在WEb应用中还需要进行web.xml的配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring-shiro-xml的一些配置"><span class="nav-number">1.6.</span> <span class="nav-text">spring-shiro.xml的一些配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Shiro内置的FilterChain"><span class="nav-number">1.6.1.</span> <span class="nav-text">Shiro内置的FilterChain</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Joker_Chen</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
